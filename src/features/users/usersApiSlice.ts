// Need to use the React-specific entry point to import `createApi`
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react"
import { createSelector } from "@reduxjs/toolkit"
import type { RootState } from "../../app/store.ts"

export type User = {
  id: number
  name: string
  username: string
  email: string
  address: {
    street: string
    suite: string
    city: string
    zipcode: string
    geo: {
      lat: string
      lng: string
    }
  }
  phone: string
  website: string
  company: {
    name: string
    catchPhrase: string
    bs: string
  }
}

export const usersApiSlice = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: "https://jsonplaceholder.typicode.com/users",
  }),
  reducerPath: "userApi",
  // Tag types are used for caching and invalidation.
  tagTypes: ["Users"],
  endpoints: build => {
    return {
      // Supply generics for the return type (in this case `QuotesApiResponse`)
      // and the expected query argument. If there is no argument, use `void`
      // for the argument type instead.

      // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
      getUsers: build.query<User[], void>({
        query: () => "/",
      }),
      getUser: build.query<User, number>({
        query: (id: number) => `/${id.toString(10)}`,
        // `providesTags` determines which 'tag' is attached to the
        // cached data returned by the query.
        providesTags: (_result, _error, id) => [{ type: "Users", id }],
      }),
      updateUser: build.mutation<User, { body: User; id: number }>({
        query: ({ body, id }) => ({
          url: `/${id.toString(10)}`,
          method: "PUT",
          body,
        }),
        invalidatesTags: ["Users"],
        async onQueryStarted({ ...patch }, { dispatch, queryFulfilled }) {
          const patchResult = dispatch(
            usersApiSlice.util.updateQueryData(
              "getUsers",
              undefined,
              (draft: User[]) => {
                const index = draft.findIndex(e => e.id === patch.id)
                if (index !== -1) {
                  draft[index] = patch.body
                }
              },
            ),
          )
          try {
            await queryFulfilled
          } catch {
            patchResult.undo()

            /**
             * Alternatively, on failure you can invalidate the corresponding cache tags
             * to trigger a re-fetch:
             * dispatch(api.util.invalidateTags(['Post']))
             */
          }
        },
      }),
    }
  },
})

// Hooks are auto-generated by RTK-Query
// Same as `tasksApiSlice.endpoints.getQuotes.useQuery`
export const { useGetUsersQuery, useUpdateUserMutation } = usersApiSlice

export const selectUserIdToName = createSelector(
  (state: RootState) => {
    return state.userApi
  },
  (userApi: RootState["userApi"]) => {
    const queries = userApi.queries
    const users = (queries["getUsers(undefined)"] ?? {
      data: [],
      status: "rejected",
    }) as { status: string; data: User[] }
    if (users.status === "rejected") {
      return {}
    }
    return users.data.reduce((acc: Record<number, string>, curr: User) => {
      acc[curr.id] = curr.name
      return acc
    }, {})
  },
)
